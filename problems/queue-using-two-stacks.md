

[/ Меню](https://github.com/samatakaya1/Interview-material/blob/main/README.md)   [/ Список задач](https://github.com/samatakaya1/Interview-material/blob/main/problems/problems.md)
---
# Задача "Реализация очереди с использованием двух стеков"


## Постановка

Необходимо реализовать структуру данных очередь (**queue**) с использованием двух стеков (**stack**). Очередь должна поддерживать основные операции, аналогичные стандартной очереди: добавление элемента в конец очереди и удаление элемента из начала очереди.

> Очередь работает по принципу **FIFO (First In, First Out)**, то есть первым удаляется элемент, который был добавлен первым. Стек работает по принципу **LIFO (Last In, First Out)**, то есть последним добавленным элементом является первым извлекаемым.
> 
---

## Требования
Реализовать следующие методы:
- **enqueue(x)** — добавляет элемент x в конец очереди.

- **dequeue()** — удаляет и возвращает элемент из начала очереди.
    Если очередь пуста, должна возвращаться ошибка или сообщение об ошибке.

- **count()** — возвращает количество элементов в очереди.


---

## Пример
```js
// Создаем очередь
const queue = new Queue();

// Добавляем элементы
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);

// Удаляем и возвращаем первый элемент
console.log(queue.dequeue()); // Вывод: 1

// Добавляем новый элемент
queue.enqueue(4);

// Удаляем элементы
console.log(queue.dequeue()); // Вывод: 2
console.log(queue.dequeue()); // Вывод: 3

// Проверяем количество элементов в очереди
console.log(queue.count());   // Вывод: 1 (остался элемент 4)
```

---

## Решения

### Алгоритм:

1. **enqueue(data)**:
    - Элемент просто помещается в stack1.
    - Так как в стек элементы добавляются в конец, это действие выполняется за O(1).

    <br/>

2. **dequeue()**:
    - Если stack2 пуст, все элементы из stack1 перемещаются в stack2. Это действие инвертирует порядок элементов, чтобы мы могли удалить элемент, который был добавлен первым (FIFO).
    - Если stack2 не пуст, просто удаляем верхний элемент из stack2.
    - Если оба стека пусты, выбрасывается ошибка.
    - Само извлечение элемента из stack2 занимает O(1).

    <br/>

3. **count()**:
    - Возвращаем сумму количества элементов в обоих стеках: stack1 и stack2.
    - Операция занимает O(1), так как просто возвращает длину массивов.
  
<br/>

> **stack1** используется для добавления новых элементов в очередь.

> **stack2** используется для извлечения элементов по правилу очереди (FIFO). Если stack2 пуст, элементы из stack1 перемещаются в stack2. Это приводит к тому, что порядок элементов меняется на обратный, и первый добавленный элемент окажется вверху stack2.

> Таким образом, операция добавления происходит быстро, но операция удаления может потребовать переноса всех элементов из stack1 в stack2 (если stack2 пуст).

### Код: 

```js
class Stack {
  constructor() {
    this.storage = [];
  }

  push(data) {
    this.storage.push(data);
  }

  pop() {
    return this.storage.pop();
  }

  size() {
    return this.storage.length;
  }
}

class Queue {
  constructor() {
    this.stack1 = new Stack();
    this.stack2 = new Stack();
  }

  // Добавить элемент в очередь
  enqueue(data) {
    this.stack1.push(data);
  }

  // Удалить и вернуть элемент из начала очереди
  dequeue() {
    // Если stack2 пуст, перемещаем все элементы из stack1 в stack2
    if (this.stack2.size() === 0) {
      while (this.stack1.size() > 0) {
        this.stack2.push(this.stack1.pop());
      }
    }

    // Если оба стека пусты, очередь пуста
    if (this.stack2.size() === 0) {
      throw new Error("Queue is empty");
    }

    return this.stack2.pop();
  }

  // Вернуть количество элементов в очереди
  count() {
    return this.stack1.size() + this.stack2.size();
  }
}
```

### Оценка сложности:

1. **enqueue(data) — O(1)**:
   - Добавление элемента в stack1 выполняется за O(1), так как это простая операция вставки в массив. 

2. **dequeue() — O(n)** в худшем случае, **O(1)** амортизированное:
   - Если **stack2** не пуст, то извлечение элемента занимает **O(1)**.
   - Если **stack2** пуст, необходимо перенести все элементы из **stack1** в **stack2**, что требует **O(n)** операций (где **n** — количество элементов в **stack1**).
   Однако, каждый элемент перемещается из **stack1** в **stack2** только один раз за всё время существования очереди. 
   Следовательно, в среднем на каждую операцию **dequeue()** приходится **O(1)** операция — это называется амортизированной сложностью.

3. **count() — O(1)**:
    - Просто возвращаем сумму длины массивов **stack1** и **stack2**, что занимает **O(1)** времени.

---
[<- К списку задач](https://github.com/samatakaya1/Interview-material/blob/main/problems/problems.md)
